\documentclass[11pt,a4paper]{article}

\usepackage{a4wide}
\usepackage{epsfig}

\title{The Matching Pursuit Tool Kit \\ User Manual and Developer's Notes}

\author{Sacha Krstulovi\'c and R\'emi Gribonval}
\date{\today, $Revision: 1107 $}

\begin{document}

\maketitle

\vfill

\tableofcontents

\vfill

\clearpage

\noindent This document aims at describing the basic principles of the Matching
Pursuit Tool Kit, and some basic guidelines about how to use it.  The appendix
also provides the potential contributor with notes about the insides of our
implementation, plus guidelines about some of the development conventions that
we have adopted. For a more detailed documentation of the code, see the
automatically generated reference manual.

%%%%%%%%%
\section{General principles \label{gen}}
%%%%%%%%%

%%%%%%%%%
\subsection{Terminology \label{term}}
%%
\paragraph{Atom --} An elementary piece of signal. An atom is characterized by
its class (e.g., Gabor atoms, harmonic atoms etc.) and a set of parameters
(e.g., for a Gabor atom, its time location and length, its frequency, its
amplitude, a chirp factor and a given shaping window). In our code, the
corresponding object knows how to subtract itself from a signal, and how to
generate its own waveform.

\paragraph{Block --} A block computes the correlations (inner products) between
a signal to analyze and a set of atoms for which the computation of the
correlations can be factorized in an efficient manner, along the whole support
of a signal.

For instance, the inner products can stem from a time-frequency transform, such
as the Fourier Transform or a wavelet transform, provided the transform can be
interpreted as a set of correlations between the signal and a set of atoms
which cover the time-frequency plane.

Each block object can search for the location of the maximum correlation
between the atoms and the signal, and can thus deduce which atom contributes
the most energy to the analyzed signal. Several blocks corresponding to various
scales or various transforms can be concurrently applied to the same signal,
thus providing for multi-scale or multiple-basis analysis.

For the moment, the following blocks are implemented:
\begin{itemize}
\item Gabor blocks, based on Short-Time Fourier Transforms, which compute the
  correlations with windowed sinusoids having a ``flat'' frequency (chirp rate
  == 0). In this case, one block is conceptually equivalent to one STFT with a
  given scale;
\item Harmonic blocks, based on the harmonic grouping of Gabor atoms, and
  inheriting from the Gabor block;
\item Chirp blocks, based on a post-processing of the Gabor atoms and aimed at
  optimizing the chirp rate;
\item AnyWave blocks, based on a fast convolution algorithm to compute some
  correlations with arbitrary waveforms.
\item MDCT/MDST/MCLT blocks. They are transforms based on local cosine functions.
\item Dirac blocks,which provide no particular time-frequency
  transform, but just find the signal samples which have a high
  energy
\item Constant blocks, which are an extension of the Dirac blocks.
  Constant atoms are rectangular windows, defined by a length and a
  shift between atoms. A constant atom catches the mean of a signal on
  the specified frame.
\item Nyquist blocks. They are defined by a length and a shift between
  atoms, and the waveform is a normalized succession of 1 and -1. A
  Nyquist atom catches the greatest frequency that can be
  distinguished (called the Nyquist frequency if the support is even)
  of the specified frame.
\end{itemize}
In the future, blocks based on fast wavelet transforms should also be designed.

\paragraph{Dictionary --} A dictionary contains a collection of blocks plus
the signal on which they operate. It can search across all the blocks (i.e.,
all the scales and all the bases) for the atom which brings the most energy to
the analyzed signal.

\paragraph{Book --} A book is a collection of atoms and its corresponding dictionaries. 
Summing all the atoms in a book gives a signal.

\bigskip

\noindent Figure~\ref{mpcycle} illustrates the fact that a dictionary contains
a signal and a collection of blocks, and that a books contains a collection of
atoms.  The algorithm linking these objects will be explained in the next
section.


%%%%%%%%%
\subsection{Algorithm \label{algo}}
%%
Our implementation of the Matching Pursuit algorithm uses roughly 3 steps, as
illustrated in figure~\ref{mpcycle}:
\begin{enumerate}
\item update the correlations in the blocks, by applying the relevant
  correlation computation algorithm to the analyzed signal, and find the
  maximum correlation in the same loop;
\item create the atom which corresponds to the maximum correlation with the
  signal (and store this atom in the book);
\item subtract the created atom from the analyzed signal, thus obtaining a
  residual signal, and re-iterate the analysis on this residual.
\end{enumerate}
At each step, the original signal can be rebuilt exactly by summing all the
atoms of the book and adding them to the residual signal.

\begin{figure}[hbp]
\vspace{2em}
\centerline{\psfig{figure=mpcycle.eps, height=10cm}}
\caption{\label{mpcycle}Our implementation of Matching Pursuit. (See
  sections~\ref{term} and~\ref{algo} for a detailed explanation.)}
\end{figure}


%%%%%%%%%
\clearpage
\section{User manual for the standalone utilities \label{man}}
%%%%%%%%%

%%%%%%%%%
\subsection{Introduction}

The Matching Pursuit standalone utilities are designed so that a typical
processing task decomposes into a chain of commands which can be connected by
pipes. The signal decomposition is performed by {\tt mpd}. The atoms stored in
the resulting books can be filtered (i.e., sorted and selected) with the
command {\tt mpf}. Several books can then be concatenated with the command {\tt
  mpcat}. Once a desired book is obtained, a corresponding approximant signal
can be rebuilt using {\tt mpr}, with the optional addition of a residual signal
(or in addition to any other signal). Alternately, the {\tt mpd\_demix} utility
provides blind source separation using Matching Pursuit when the mixing matrix
is known. Each of the cited utilities have a {\tt -h} switch to get
command-line help.

\smallskip

Some typical processing chains include:

\begin{itemize}
\item Signal approximation with N atoms: \\
      \mbox{\tt mpd -D dictionary -n N soundFile.wav book.bin;} \\
      \mbox{\tt mpr book.bin approx.wav} \\
      -- or -- \\
      \mbox{\tt mpd -D dictionary -n N soundFile.wav - | mpr - approx.wav}
\item Exact reconstruction: \\
      \mbox{\tt mpd -D dictionary -n N soundFile.wav book.bin residual.wav;} \\
      \mbox{\tt mpr book.bin approx.wav residual.wav}
\item Signal approximation, using only the short atoms (e.g., of less than
128~samples) \linebreak and ignoring the residual: \\
      \mbox{\tt mpd -D dictionary -n N soundFile.wav book.bin;} \\
      \mbox{\tt mpf --length=[0:128] book.bin bookShort.bin;} \\
      \mbox{\tt mpr bookShort.bin approx.wav}
\item Blind source separation and rebuilding an approximation of one of the
  sources (e.g., the~3rd one): \\
      \mbox{\tt mpd\_demix -D dictionary -M matrix.txt -n N mix.wav bookFile;} \\
      \mbox{\tt mpr bookFile\_3.bin approxOfSource3.wav}
\end{itemize}
Lots of other combinations are possible. The relevant utilities are described
with more detail in the next sections.

\paragraph{Note about the signal file formats} -- MPTK has been originally designed for sound
processing, but it is applicable to any kind of signal.

For input, we have mostly been using the WAV format, but any file format
recognized by the \verb+libsndfile+ library (i.e., most audio formats, see
\verb+http://www.mega-nerd.com/libsndfile/+) should work with the provided MPTK
utilities.

The signal output is more specific: the MPTK binaries output signals in the WAV
format only. {\em (WARNING: in the \verb+libsndfile+ implementation, this
  format is not protected against clipping, which may happen for some books and
  is not an artifact of the MPTK analysis.)} Nevertheless, the MPTK API also
offers Matlab, raw \verb+double+ and raw \verb+float+ signal output formats:
those could be quickly enabled by simple hacks of the relevant utilities. To
enable other output formats, please contribute some code to the
\verb+mp_signal.{h,cpp}+ API.

\subsection{the MPTK environment}
In order to define the working environment of Matching Pursuit utilities, 
An XML file is loaded before using Matching Pursuit. This XML file contains
the configuration path \verb+<configpath>+ path\verb+</configpath>+ the syntax
of the path is \verb+<path name="NAME" path="PATH"/>+ the path used are:

\begin{itemize}
 \item \verb+dll_directory+ the directory where MPTK library search for plugins
                            Dynamic Link Library (DLL) defining atoms and blocks
 \item \verb+fftw_wisdomfile+ the default path for the FFTW wisdom file which allows
                              to save the setting for FFT computation.
\end{itemize}

This values can be set by two way, the complete path of the file can be specified
with the \verb+-C<FILE>, -config-file=<FILE>+ for utilities or MPTK library calls 
the environment variable \verb+MPTK_CONFIG_FILENAME+ to determine
which file to use for setting up the MPTK environment.


\clearpage
%%%%%%%%%
\subsection{mpd: matching pursuit signal decomposition}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpd_Usage}
	\end{minipage}
\end{center}

\subsection{gpd: gradient pursuit signal decomposition}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/gpd_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{mpf: filtering of the book files}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpf_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{mpcat: concatenation of book files}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpcat_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{mpr: signal reconstruction}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpr_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{mpd\_demix: blind source separation with a known mixing matrix}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpd_demix_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{mpview: generation of a time-frequency map from a book}
%%%%%%%%%
\begin{center}
	\begin{minipage}{0.8\linewidth} 
		\input{CommandUsage/mpview_Usage}
	\end{minipage}
\end{center}

%%%%%%%%%
\subsection{Format of the dictionary files \label{dict_format}}
%%%%%%%%%
The dictionary files use a XML syntax, with tags enclosed between
angle brackets. Strict XML compliance is now mandatory.
\footnote{Uh, that is, if a DTD get ready someday.}.

\subsubsection*{General rules}
A dictionary should include, in the following order:
\begin{enumerate}
\item an optional XML declaration line;
\item a mandatory dictionary opening tag;
\item an optional library version tag;
\item a list of blocks with their parameters (some parameters being mandatory,
  some admitting default values);
\item a dictionary closing tag.
\end{enumerate}
Any text included after the dictionary closing tag will be ignored. Blank
spaces and line breaks are ignored. Any part of the file can be commented out
either by enclosing it between \verb+<!--+ and \verb+-->+ (XML style) 
The parser will send any text it can't match to stderr with a error message:
in the event of syntax errors in a dictionary, some dictionary
pieces will therefore show up in stderr.


\subsubsection*{Valid tags}
\begin{itemize}


\item \verb+<?xml version="1.0" encoding="ISO-8859-1"?>+ [optional]: the XML
  declaration line.
  
\item \verb+<dict>+List of blocks\verb+</dict>+: the opening and closing tags
  for the dictionary. Anything coming after the \verb+</dict>+ tag will be
  ignored by the parser.
  
\item \verb+<libVersion>+blah\verb+</libVersion>+ [optional]: the library
  version declaration. This is provided for backward compatibility if we ever
  change the dictionary syntax. When absent, the library version is taken to be
  the current one.
  
\item \verb+<blockproperties name="PROPERTIES_NAME">+List of block parameters\verb+</blockproperties>+: 
  the opening and closing tags for a block properties list.this 
  
\item \verb+<block uses="PROPERTIES_NAME">+List of block parameters\verb+</block>+:
  the opening and closing tags for a block. The block will be construct using the list of
  parameters defined in \verb+PROPERTIES_NAME+ block properties.
  
\item \verb+<block>+List of block parameters\verb+</block>+:
  the opening and closing tags for a block. the list of block parameters should
  contains all the mandatories parameters for this type of block
  
\item \verb+<par type="NAME" value="VALUE"/>+ : a block
  parameter. The \verb+NAME+ and corresponding \verb+VALUE+ value in string.
  The parameter value is set to the corresponding type when the dictionary file is parsed.

  Note that when using the \verb+<block uses="PROPERTIES_NAME">+List of block parameters
  \verb+</block>+ syntax. The block parameters defined in the block list override the parameters
  from \verb+PROPERTIES_NAME+ block properties.


  The list of parameters for relevant block types (G==gabor, H==harmonic, C==Chirp, A==Anywave,
  CT==constant, N==nyquist) are given below:
  \begin{itemize}

  \item (G,H,C,CT,N) \verb+windowLen+ with an unsigned long int value: the atom length
    (i.e., the window length in the STFT).

  \item (G,H,C,A,CT,N) \verb+windowShift+ with an unsigned long int value: the atom
    shift (i.e., the window shift in the STFT).
    
  \item (G,H,C) \verb+windowRate+ with a double value between 0.0 and 1.0: an
    alternate way to specify the window shift, as a proportion of the
    windowLen.  If both are present, \verb+windowShift+ has precedence over
    \verb+windowRate+.
    
  \item (G,H,C) \verb+fftSize+ with an unsigned long value: the frequency
    resolution in terms of FFT size. It has to be greater or equal to
    \verb+windowLen+ if \verb+windowLen+ is even, or $\geq$\verb2(windowLen+1)2
    if \verb+windowLen+ is odd. If absent, defaults to \verb+windowLen+ (or
    \verb2windowLen+12).
    
  \item (G,H,C,CT,N) \verb+blockOffset+ with an unsigned long value: the block Offset, 
    i.e. the position of the first frame. If absent, defaults to 0.
    
  \item (G,H,C,CT,N) \verb+windowtype+ the window specification to be included
    among the block parameters.
    
  \item (G,H,C,CT,N) \verb+windowopt+ the optional parameter for window type:
 \begin{itemize}
     
  \item The following \verb+windowtype+s do not require the \verb+windowopt+
  attribute: \\ \verb+rectangle+, \verb+triangle+, \verb+cosine+, \verb+hanning+,
  \verb+hamming+, \verb+blackman+, \verb+flattop+, \verb+fof+.
     
  \item The following \verb+windowtype+s do require the \verb+windowopt+
  attribute: \\ \verb+hamgen+, \verb+gauss+, \verb+exponential+. \\
  The meaning of the optional parameter varies according to the window type.
  See the reference manual for more info.
 \end{itemize}
    
  \item (H) \verb+f0Min+ with a double value: minimum frequency (in Hz) from
    which the fundamental frequency of the harmonic atoms is searched. Defaults
    to the first non-null FFT frequency.
    
  \item (H) \verb+f0Max+ with a double value: maximum frequency (in Hz) at
    which the fundamental frequency of the harmonic atoms is searched.
    Defaults to the Nyquist frequency of the considered signal.
    
  \item (H) \verb+numPartials+ with an unsigned int value: number of partials
    considered when tracking the harmonic atoms.
    
  \item (C) \verb+numFitPoints+ (EXPERIMENTAL) with an unsigned int value:
    number of polynomial fitting points considered for the chirp optimization
    algorithm. Defaults to 1.
    
  \item (C) \verb+numIter+ (EXPERIMENTAL) with an unsigned int value: number of
    iterations considered for the chirp optimization algorithm. Defaults to 1.
    
  \item (A) \verb+tableFileName+ with a string: filename of the table
    containing the waveforms (ex: ---/udd/toto/table.bin--- ). Note that there
    is no {"} around the string.

  \end{itemize}
  Note that the \verb+dirac+ blocks don't need any parameter (they just match
  signal samples).

\end{itemize}

\subsubsection*{Example}

\begin{verbatim}
<?xml version="1.0" encoding="ISO-8859-1"?>        <= The optional XML
                                                      declaration line.
<dict>                                             <= The dictionary opening tag.
<libVersion>0.2</libVersion>                       <= The optional library version.

        <blockproperties name="GAUSS-WINDOW">      <= A new block properties.
                <param name="windowtype" value="gauss"/>
                <param name="windowopt" value="0.02"/> <= Gauss windows need
                                                             a parameter.
        </blockproperties>
        <blockproperties name="HAMMING-WINDOW">    <= Another block properties.
                <param name="windowtype" value="hamming"/>
                <param name="windowopt" value="0"/> <= The hamming window
                                                       ignores the opt="0"
                                                       attribute.
        </blockproperties>

        <block uses="GAUSS-WINDOW">                 <= A new block using
                                                       GAUSS-WINDOW block properties.
                <param name="type" value="gabor"/>
                <param name="windowLen" value="32"/>
                <param name="windowShift" value="32"/>
                <param name="fftSize" value="32"/>
        </block>

        <blockproperties name="GAUSS-WINDOW-BIS" refines="GAUSS-WINDOW">
                <param name="windowopt" value="0.02"/> <= A new block properties overriding
                                                          the GAUSS-WINDOW block properties.
        </blockproperties>

        <block uses="GAUSS-WINDOW-BIS">             <= A new block using
                                                       GAUSS-WINDOW-BIS block properties.
                <param name="type" value="gabor"/>
                <param name="windowLen" value="32"/>
                <param name="windowRate" value="0.25"/>   <= This is equivalent to
                                                       setting windowShift=16.
                <param name="fftSize" value="64"/>
        </block>
        <blockproperties name="WINDOW-SHIFT">           <= A new block properties.
                <param name="windowShift" value="32"/>  <= A value for the
                                                        window shift.
        </blockproperties>

        <block uses="WINDOW-SHIFT">
                <param name="windowLen" value="128"/>
<!--            <param name="windowShift" value="32"/>     <= These lines are
                <param name="fftSize" value="128"/>   -->  commented out.
                                                           This block will use
                                                           the default
                                                           windowShift from
                                                           WINDOW-SHIFT, and will default
                                                           fftSize to windowLen.
        </block>
        <block uses="GAUSS-WINDOW">
                <param name="type" value="gabor"/>	
                <varparam name="fftSize">                 <= A variable parameter list.
                        <var>64</var>                        a list of block for each value
                        <var>32</var>                        of the variable parameter list.
                        <var>16</var> 
                        <var>8</var>
                </varparam>
                <param name="windowLen" value="8"/>
                <varparam name="windowShift">            <= Another variable parameter list.
                        <var>64</var>                        a list of block for each value
                        <var>32</var>                        of the variable parameter list,
                        <var>16</var>                        combined with the list of block 
                </varparam>                                  defined above.
        </block>
        <block uses="GAUSS-WINDOW-BIS">
                <param name="type" value="harmonic"/>    <= A harmonic block.
                <param name="fftSize" value="256"/>
                <param name="windowLen" value="256"/> 
                <param name="windowShift" value="128"/> 
                <param name="f0Min" value="340"/> 
                <param name="f0Max" value="1000"/>
                <param name="numPartials" value="5"/>
        </block>
        <block uses="GAUSS-WINDOW"> 
                <param name="type" value="chirp"/>       <= A chirp block.
                <param name="fftSize" value="1024"/>
                <param name="windowLen" value="1024"/> 
                <param name="windowShift" value="128"/> 
                <param name="numFitPoints" value="2"/> 
                <param name="numIter" value="1"/>
        </block>
        <block>
                <param name="type" value="anywave"/>       <= An anywave block.
                <param name="tableFileName" value="/udd/toto/table.xml"/>
                <param name="windowShift" value="1"/>
        </block>
        <block>
                <param name="type" value="dirac"/>         <= A dirac block.
        </block>
        <block>
                <param name="type" value="constant"/>      <= A constant block.
                <param name="windowLen" value="512"/>
                <param name="windowShift" value="32"/>
        </block>
        <block>
                <param name="type" value="nyquist"/>      <= A nyquist block.
                <param name="windowLen" value="512"/>
                <param name="windowShift" value="32"/>
        </block>
</dict>
This is that great dictionary I used for obtaining        <= This text is ignored
these wonderful experimental results thanks to the           by the parser.
Matching Pursuit Library ...
\end{verbatim}

\subsubsection*{Anywave table}

Waveforms need have been loaded before using anywave atoms. That's the
difference between parametric atoms, such as Dirac, Gabor, ... and anywave
atoms. Therefore, a different syntax has to be employed. In the dictionary
file, the anywave block points to a ``anywave table definition file''
(/udd/toto/table.bin in the example). This file has a XML syntax, to give all
the parameters of the waveforms, and points to a binary ``anywave table data
file'', that gives the data (/udd/toto/table\_data.bin in the example).

Note that one table corresponds to one atom length, and one number of channels.
To use several atom lengths, one must create several anywave tables, and define
several ``anywave'' blocks.

The ``anywave table definition file'' is structured as follows:

\begin{itemize}
  
\item \verb+<?xml version="1.0" encoding="ISO-8859-1"?>+ [optional]: the XML
  declaration line. It is ignored by the parser.
  
\item \verb+<table>+List of table parameters\verb+</table>+: the opening and
  closing tags for the table. Anything coming after the \verb+</table>+ tag
  will be ignored by the parser.
  
\item \verb+<libVersion>+blah\verb+</libVersion>+ [optional]: the library
  version declaration. This is provided for backward compatibility if we ever
  change the dictionary syntax. When absent, the library version is taken to be
  the current one.
  
\item \verb+<par type="NAME" value="VALUE"/>+ : a table parameter.
  The \verb+NAME+ and corresponding \verb+VALUE+ value in string.
  The parameter value is set to the corresponding type when the table parameter file is parsed.
  The \verb+NAME+ and corresponding \verb+VALUE+s types are given below:
  \begin{itemize}
    
  \item \verb+numChans+ with an unsigned short int value: the number of
    channels of the atoms.
  \item \verb+filterLen+ with an unsigned long int value: the length of the
    anywave waveforms in the table.
  \item \verb+numFilters+ with an unsigned long int value: the number of
    anywave waveforms in the table.
  \item \verb+data+ with a string: name of the file containing the waveforms
    data (ex: ---/udd/toto/table\_data.bin--- ). Note that there is no {"}
    around the string.

  \end{itemize}
\end{itemize}

The ``anywave table data file'' is binary, and built as follows: all the
waveforms are written in double type, one after the other, and for each, one
channel after the other. The following scheme is for two channels and four
waveforms: {\center |w1c1|w1c2|w2c1|w2c2|w3c1|w3c2|w4c1|w4c2| }

\subsubsection*{Example of an anywave table}
\begin{verbatim}
<?xml version="1.0" encoding="ISO-8859-1"?>        <= The optional XML
                                                      declaration line.
<table>                                           <= The table opening tag
                                                     (only one table per file
        <libVersion>0.4beta</libVersion>          <= The optional library version.
        <param name="numChans" value="1"/>
        <param name="filterLen" value="64"/>
        <param name="numFilters" value="20"/>
        <param name="data" value="/udd/toto/table_data_001.bin"/>
</table>                                          <= The table closing tag.
\end{verbatim}

\subsubsection*{MDCT/MDST/MCLT}

\textbf{Definition} The Modified Discrete Cosine Transform (MDCT) and the Modified Discrete Sine Transform (MDST) are two orthogonal transforms based on local cosine functions. The Modulated Complex Lapped Transform (MCLT) is the complex extension such as $MCLT=MDCT+i*MDST$. The atoms corresponding to the MCLT of a signal of length $N=PL$ and a window length of $2L$, are defined as:
\begin{equation}
x_{p,k}(n) = w(n-pL) exp \left[ i \frac{\pi}{L} \left( (n-pL) + \frac{1}{2} + \frac{L}{2} \right) \left( k + \frac{1}{2} \right) \right]
\end{equation} 
with $n=0,..,N-1$, $k=0,..,L-1$ and $p=0,..,P-1$. $w$ is a window which is complementary in energy i.e. it verifies $w^2 (n) + w^2 (n+L) = 1, n=0,..,L-1$.

The atoms corresponding to the MDCT are defined as the real part of the previous formula and the atoms corresponding to the MDST the imaginary part of the previous formula.

We also define a generalized MDCT/MDST/MCLT where the window shift, the window shape and the fft size are not constraint by the orthogonality property. The corresponding atoms for a signal of length $N=PS$, a window length of $2L$, a window shift of $S$, a fft size of $Nfft$ and a window $w$, are defined as:
\begin{eqnarray}
x_{p,k}(n) = w(n-pS) exp \left[ i \frac{2\pi}{Nfft} \left( (n-pS) + \frac{1}{2} + \frac{L}{2} \right) \left( k + \frac{1}{2} \right) \right] \mbox{ if } Nfft=2L \\
x_{p,k}(n) = w(n-pS) exp \left[ i \frac{2\pi}{Nfft} \left( (n-pS) + \frac{1}{2} + \frac{L}{2} \right) \left( k  \right) \right] \mbox{ if }Nfft=2mL
\end{eqnarray}
with $n=0,..,N-1$, $k=0,..,Nfft/2-1$, $p=0,..,P-1$ and m is even with $m>=2$.

\textbf{Valid tags}
\begin{itemize}

\item \verb+<?xml version="1.0" encoding="ISO-8859-1"?>+ [optional]: the XML
  declaration line. It is ignored by the parser.
  
\item \verb+<libVersion>+blah\verb+</libVersion>+ [optional]: the library
  version declaration. This is provided for backward compatibility if we ever
  change the dictionary syntax. When absent, the library version is taken to be
  the current one.

\item \verb+<dict>+List of blocks\verb+</dict>+: the opening and closing tags
  for the dictionary. Anything coming after the \verb+</dict>+ tag will be
  ignored by the parser.
  
  The list of parameters for relevant block types (G==gabor, H==harmonic, C==Chirp, A==Anywave,
  CT==constant, N==nyquist) are given below:
  \begin{itemize}

  \item \verb+windowLen+ with an unsigned long int value: the atom length
    (i.e., the window length). It has to be even.

  \item \verb+windowShift+ with an unsigned long int value: the atom
    shift (i.e., the window shift).
    
  \item \verb+windowRate+ with a double value between 0.0 and 1.0: an
    alternate way to specify the window shift, as a proportion of the
    windowLen.  If both are present, \verb+windowShift+ has precedence over
    \verb+windowRate+.
    
  \item \verb+fftSize+ with an unsigned long value: the frequency
    resolution in terms of FFT size. It has to be equal to \verb+windowLen+ or a multiple of 2*\verb+windowLen+.
    
  \item \verb+blockOffset+ with an unsigned long value: the block Offset, 
    i.e. the position of the first frame. If absent, defaults to 0.
    
  \item  \verb+windowtype+ the window specification to be included
    among the block parameters.
    
  \item  \verb+windowopt+ the optional parameter for window type:
 \begin{itemize}
     
  \item The following \verb+windowtype+s do not require the \verb+opt=""+
  attribute: \\ \verb+rectangle+, \verb+triangle+, \verb+cosine+, \verb+hanning+,
  \verb+hamming+, \verb+blackman+, \verb+flattop+, \verb+fof+.
     
  \item The following \verb+windowtype+s do require the \verb+opt=""+
  attribute: \\ \verb+hamgen+, \verb+gauss+, \verb+exponential+, \verb+kbd+. \\
  The meaning of the optional parameter varies according to the window type.
  See the reference manual for more info.
\end{itemize}
\end{itemize}
\end{itemize}

A default MDCT/MDST/MCLT block is defined using 2 parameters, the window length and the window type. The window type must be \verb+rectangle+, \verb+cosine+ or \verb+kbd+. An example of a MDCT dictionnary is:
\begin{verbatim}
<?xml version="1.0" encoding="ISO-8859-1"?>
<dict>
<libVersion>0.2</libVersion>
     <block>
          <param name="type" value="mdct"/>
          <param name="windowLen" value="2048"/>
          <param name="windowtype" value="kbd"/>
          <param name="windowopt" value="5"/>
     </block>
</dict>
\end{verbatim}

An example of a generalized MCLT dictionnary is:
\begin{verbatim}
<?xml version="1.0" encoding="ISO-8859-1"?>
<dict>
<libVersion>0.2</libVersion>
     <block>
          <param name="type" value="mdct"/>
          <param name="windowLen" value="2048"/>
          <param name="fftSize" value="4096"/>
          <param name="windowtype" value="cosine"/>
          <param name="windowopt" value="0"/>
     </block>
</dict>
\end{verbatim}

%%%%%%%%%
\clearpage
\section{The GUI \label{gui}}
%%%%%%%%%
A wxWidget-based Graphical User Interface is delivered as the \verb+MptkGuiApp+
binary, in the \verb+./src/gui/+ directory. It is not compiled/installed by
default: use \verb+--enable-gui+ with the \verb+configure+ script if you want
to use it. The initial version of this GUI has been developed in the framework
of an IFSIC/DIIC3 student project by: Nicolas Bonnet, Benjamin Boutier, Vincent
Chapon and Sylvestre Cozic. (Thanks!)

This GUI takes up the functionality of \verb+mpd+ and \verb+mpr+ (no atom
filtering implemented), and adds visualization/audio playback capabilities for
the books and signals. Globally, it offers a friendlier control of the
decomposition process. In its current state, it remains bug-prone and poorly
documented, but it can help vizualizing and understanding the Matching Pursuit
decomposition process in a nice way.


%%%%%%%%%
\section{Extra utilities: visualization of MP books under Matlab \label{matlab}}
%%%%%%%%%

Some Matlab utilities are bundled with the distribution to help loading and
visualizing books under Matlab. They can be found in the ./extras/matlab/
directory of the source tree. They are not automatically installed by the
configure system: you should copy them manually to a location accessible to
your MATLABPATH.

\bigskip

\noindent The included files are:
\begin{itemize}
\item bookread.m: to load a binary book into Matlab;
\item bookplot.m: to plot a book in a spectrogram-like fashion;
\item bookover.m: to overlay a book plot on a STFT spectrogram.
\item dictread.m: under development. Don't use.
\end{itemize}
Each of these functions is equipped with some help info, e.g. to get help about
bookplot use:\\
\verb+    >> help bookplot+ \\
under Matlab.


%%%%%%%%%
\appendix
%%%%%%%%%

%%%%%%%%%
\clearpage
\section{Development conventions}
%%%%%%%%%

%%%%%%%%%
\subsection{Typographic conventions}
Throughout the source code, the following typographic conventions are
preferably adopted:
\begin{itemize}
\item {\bf myVar} for variables;
\item {\bf my\_function} for functions;
\item {\bf MP\_MY\_CONST} for constants (\#define) and for global variables;
\item {\bf MP\_My\_Type\_t} for types;
\item {\bf MP\_My\_Class\_c} for classes.
\end{itemize}

%%%%%%%%%
\subsection{Memory allocation conventions}
The arrays are allocated using malloc (NOT new[]) and freed using free (NOT
delete[]). Conversely, the objects are created and deleted using new and
delete.

%%%%%%%%%
\subsection{Source code locations}
From the source tree, the doc sources are stored in doc/, and the code sources
in src/. Then\,:
\begin{itemize}
\item the bulk of the Matching Pursuit library is stored in src/libmptk/.
  Specifically, the implementation of blocks and atoms related to specific
  time-frequency transforms should be located in src/plugin/. As a
  matter of fact, you should not have to modify other parts of the code when
  adding new classes of blocks and atoms. Think of it as a sort of plugin
  logic;
\item a standalone library (in C) to compute standard signal processing windows
  is stored in src/libdsp\_windows/;
\item the applications are stored in src/utils/;
\item a test suite is stored in src/tests/.
\end{itemize}
For the implementation of each class, we use one .h header file to declare the
class, plus a corresponding .cpp source with the same base name to implement
its methods. During a build, the .h headers are concatenated in one global
mptk.h header which should be the one included in all the individual .cpp
files.


%%%%%%%%%
\subsection{Building and portability}

\paragraph{Building system --} We use the CMake build system
to automatically adapt the building process to your particular flavor of Unix,
MAC OS X or Windows Win32. Therefore, every system call should be performed 
through the ``mp\_system.h''header file located at the top of the source tree.

\paragraph{Binary format and byte order --} The byte-order of any binary output
is forced to be the LITTLE\_ENDIAN order, native on Intel ($\Rightarrow$ most
PCs and the new Macs) and VAX\footnote{Dude, if you have a VAX alive, we would
  sure like to know if MPTK runs on it.}, swapped on PowerPC ($\Rightarrow$
Macintosh PPC), SPARC ($\Rightarrow$ SUN workstations) and Motorola.


%%%%%%%%%
\subsection{Installed files}
\begin{itemize}
\item Static libraries get installed in \verb+EPREFIX/lib+:
\begin{itemize}
\item \verb+libdsp_windows+: a standalone library to compute standard signal processing windows.
\item \verb+libtinyxml+: a standalone library to parse XML dictionary structure file
\end{itemize}
\item Dynamic Link Libraries (DLL) get installed in \verb+EPREFIX/lib+:
\begin{itemize}
\item \verb+libmptk+: the MPT core library
\item \verb+"ATOMNAME"Atom+: the \verb+"ATOMNAME"+ atom plugin, which is dynamically loaded
when MPTK environment is loaded.
\item \verb+"BLOCKNAME"Atom+: the \verb+"BLOCKNAME"+ block plugin, which is dynamically loaded
when MPTK environment is loaded.
\end{itemize}
\item MPTK environment configuration file: \verb+pathµ.xml+ gets installed in \verb+PREFIX/bin+.
\item Headers: \verb+mpth.h+ gets installed in \verb+PREFIX/include+.
\item Binaries: \verb+mpd+, \verb+mpd_demix+, \verb+mpf+, \verb+mpr+, \verb+mpcat+,
  \verb+mpview+ and optionally \verb+MptkGuiApp+ get installed in
  \verb+EPREFIX/bin+. The binaries from \verb+./src/test/+ do not get installed.
\item Documentation: the documentation is delivered in \verb+./doc+, both in
  built form and source form, but does not get installed. Copy it manually to
  your favorite location.
\item Extras: matlab interface files are delivered in \verb+./extras/matlab+,
  but do not get installed. Copy them manually to a location accessible from
  your MATLABPATH.
\end{itemize}


%%%%%%%%%
\clearpage
\section{Development tricks and notes}
%%%%%%%%%

%%%%%%%%%
\subsection{Class interfacing and code factorization}
%%
To allow the dictionary to manage every class of blocks (i.e., every different
time-frequency transform) in the same way, every specific block class inherits
from a generic block class which implements some mandatory methods.  Similarly,
all the atoms inherit from a generic atom class, so that they can perform a
certain number of standard operations and so that they can be stored in books.
Please refer to the reference manual and code headers for more details.


%%%%%%%%%
\subsection{Speed tricks}
%%
Our general philosophy is to avoid as much as possible to compute the same
operation twice.  For example, in the blocks, the update of the time-frequency
transforms is executed only along the part of the signal that were modified by
subtracting an atom at the previous step.

\paragraph{Tree for the max search} -- The outcome of the time-frequency
transforms is stored as a single dimension vector. After each update of the
time-frequency transforms, the location of the maximum correlation can be
anywhere along the vector. To avoid browsing the whole length of it each time
we perform a max correlation search, we use a tree structure which keeps track
of local maxima (figure~\ref{tree}).
%
\begin{figure}[hbp]
\centerline{\psfig{figure=tree.eps, height=10cm}}
\caption{\label{tree} Use of a tree to speed up the max search: at each
  iteration, only the grey-shaded parts, modified by the previous atom
  subtraction, are browsed.}
\end{figure}

\paragraph{Tabulations} -- The signal processing windows are tabulated
in a window server (called by the blocks and the atoms) which has global scope
over the whole code. The atom cross-correlations are computed and tabulated at
block creation time.


%%%%%%%%%
\subsection{The parser for XML dictionaries: TinyXML}
%%
The parsing of the XML dictionary is implemented using tinyXML.
TinyXML is a simple, small, C++ XML parser that can be easily integrating
into other programs. TinyXML has evolved from community feedback and
become the work of many contributors. It is a simple, stable, basic XML
parser used by many open source and commercial products.

%%%%%%%%%
\subsection{Experimental hacks and limitations -- !!READ THIS!!}
%%

\paragraph{Harmonic block} -- {\sc In its current implementation, the harmonic block
  allows for an increase of the signal energy for certain ``ill choosen''
  values of f0Min (the lower authorized base frequency).}

As a matter of fact, for low f0 values, the various Gabor atoms making the
harmonic components are not strictly orthogonal, although they are treated as
such when removing the whole harmonic atom from the analyzed signal. Various
solutions are possible, such as subtracting the harmonic atom in a truly
orthogonal way (implying the computation of the Gram-Schmidt matrix of the
Gabor components), removing the Gabor components individually in an iterative,
stepwise orthogonal way, or limiting f0Min on the basis of tabulated values
(related to the window types and dimensions). None of these solutions has been
implemented yet.

\paragraph{Chirp block} -- The chirp optimization method is well understood
at the theoretical level, but its practical behaviour needs to be studied in
more detail. It has been observed that high chirp rates may lead to wrong
correlations and an increase of the signal energy. To avoid pathological cases,
three noteworthy tricks have been used:
\begin{itemize}
\item after each iteration of chirp rate estimation, it is verified that the
  inner product (IP) with the signal is augmented. If not, the last valid ``IP
  increasing'' chirp value is returned;
\item at the relocation step in the chirp estimation process, the atom can not
  jump further than 10 FFT bins from its current location (lines using
  \verb+MP_FREQ_RELOC_RANGE+);
\item the chirp rate estimate is arbitrarily bounded by a value of
$0.5\cdot10^{-5}$ (code labelled \verb+/* BORK */+ in \verb+chirp_block.cpp+).
This value should be made a block parameter and correlation behaviour at high
chirp rates should be better explored.
\end{itemize}
In addition, the effect of the number of iterations and number of fit points
deserves a deeper study. So far, 1 iteration with numFitPoints=1 seems to give
acceptable results, so the usefulness of an iterative process is questionable.



%%%%%%%%%
\clearpage
\section{References}
%%%%%%%%%
\paragraph{Algorithmic aspects} For more information about the algorithmic
aspects of the Matching Pursuit algorithm, see: \newline \cite{Zhang93},
\cite{MZ93}, \cite{PRK93}, \cite{Davis94}, \cite{Bergeaud},
\cite{BM96}, \cite{HRP}, \cite{HRMP1}, \cite{HRMP2}, \cite{DMA97},
\cite{goodwin99:_match}, \cite{MaThese}, \cite{Grib2001}, \linebreak
\cite{Grib2002a}, \cite{gribonval03:_harmon_decom_audio_signal_match_pursuit},
\cite{SPIE03:GribA}, \cite{IC06MPTK}.

\paragraph{Theoretic aspects} For more information about the theoretic aspects
of the Matching Pursuit algorithm, see: \newline
\cite{Grib2001b}, \cite{GN2001}, \cite{Grib2001c}, \cite{ICIP03:GN},
\cite{gribonval03:_spars}, \cite{IRISA03:GV}, \cite{gribonval03:_highl},
\cite{GribFig}.

\paragraph{Experimental results and applications} Examples of experimental and
applicative results obtained with MPTK can be found in: \newline
\cite{WASPAA05}, \cite{LESAGE_ICA06}.


%%%%%%%%%
{\bibliographystyle{apalike}
\bibliography{biblio_MP}}

\end{document}


