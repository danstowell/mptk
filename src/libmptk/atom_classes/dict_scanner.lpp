%{

/******************************************************************************/
/*                                                                            */
/*                             dict_scanner.cpp                               */
/*                                                                            */
/*                        Matching Pursuit Library                            */
/*                                                                            */
/* Rémi Gribonval                                                             */
/* Sacha Krstulovic                                                           */
/* Sylvain Lesage                                             Mon Feb 21 2005 */
/* -------------------------------------------------------------------------- */
/*                                                                            */
/*  Copyright (C) 2005 IRISA                                                  */
/*                                                                            */
/*  This program is free software; you can redistribute it and/or             */
/*  modify it under the terms of the GNU General Public License               */
/*  as published by the Free Software Foundation; either version 2            */
/*  of the License, or (at your option) any later version.                    */
/*                                                                            */
/*  This program is distributed in the hope that it will be useful,           */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/*  GNU General Public License for more details.                              */
/*                                                                            */
/*  You should have received a copy of the GNU General Public License         */
/*  along with this program; if not, write to the Free Software               */
/*  Foundation, Inc., 59 Temple Place - Suite 330,                            */
/*  Boston, MA  02111-1307, USA.                                              */
/*                                                                            */
/******************************************************************************/
/*
 * SVN log:
 *
 * $Author$
 * $Date$
 * $Revision$
 *
 */

/* The dict_scanner.cpp source is automatically generated from
   the dict_scanner.l template, using the FLEX lexical scanner generator.
   Any manual change will be lost at the next build. Changes should be introduced
   in the dict_scanner.l file. See "man flex" for more info. */

#include "mptk.h"
#include "mp_system.h"

#include <dsp_windows.h>

/* Redefine yylex to take a MP_Scan_Info_c* as input */
#define YY_DECL int yylex( MP_Scan_Info_c *scanInfo )

/* A few global variables */
unsigned long int *dict_scan_ulongPtr = NULL;
unsigned int *dict_scan_uintPtr = NULL;
double *dict_scan_doublePtr = NULL;
char* dict_scan_stringPtr = NULL;
unsigned char *dict_scan_ucharPtr = NULL;
bool *dict_scan_boolPtr = NULL;
bool *dict_scan_boolPtr2 = NULL;

%}

%option noyywrap
%option stack
%option prefix="dict_scan_" outfile="lex.yy.c"

%x XMLTRASH
%x CTRASH

%x SCAN_ULONG
%x SCAN_UINT
%x SCAN_DOUBLE
%x SCAN_STRING

%s SCAN_WINDOW
%x SCAN_WINDOWTYPE

%s SCAN_LIBVERSION
%s SCAN_BLOCKTYPE
%s SCAN_PAR
%s SCAN_GLOB

%%

[[:space:]]+	/* Trash the isolated series of blank spaces */ ;

\<\?xml.*\?\>	/* Ignore the XML declaration line */ ;


"\<!--"			  yy_push_state(XMLTRASH); /* Trash any XML style comments */

<XMLTRASH>[^\-]*	  /* eat anything that's not a '-' */

<XMLTRASH>"-"+[^\-\>]*	  /* eat up '-'s not followed by '->' */

<XMLTRASH>"-"+"-\>"	  yy_pop_state(); /* Get out of XML style comments */


"/*"			  yy_push_state(CTRASH); /* Trash any C style comments */

<CTRASH>[^*]*		  /* eat anything that's not a '*' */

<CTRASH>"*"+[^*/]*	  /* eat up '*'s not followed by '/'s */

<CTRASH>"*"+"/"		  yy_pop_state(); /* Get out of C style comments */


#.*$		/* Trash any shell-style comments */ ;

"//".*$		/* Trash any CPP-style comments */ ;


<SCAN_ULONG>[[:space:]]*[0-9]*[[:alpha:]\.\+-]+.*/\<    {
					fprintf( stderr, "mplib error -- yylex() - [%s] is a wrong string"
						  " to describe an unsigned long value. Please check the syntax"
						  " of your dictionary and use only the digits from 0 to 9.\n",
						  yytext );
					return( ERROR_EVENT );
				}

<SCAN_ULONG>[[:space:]]*[0-9]+    {
				    if (dict_scan_ulongPtr) {
				       *dict_scan_ulongPtr = strtoul( yytext, NULL, 10 );
				       *dict_scan_boolPtr = true;
				    }
				    else {
					 fprintf( stderr, "mplib error -- yylex() - Tried to read an unsigned long into"
						  " a NULL pointer.\n" );
					 return( ERROR_EVENT );
				    }
				    yy_pop_state();
				}

<SCAN_UINT>[[:space:]]*[0-9]*[[:alpha:]\.\+-]+.*/\<    {
					fprintf( stderr, "mplib error -- yylex() - [%s] is a wrong string"
						  " to describe an unsigned int value. Please check the syntax"
						  " of your dictionary and use only the digits from 0 to 9.\n",
						  yytext );
					return( ERROR_EVENT );
				}

<SCAN_UINT>[[:space:]]*[0-9]+    {
				    if (dict_scan_uintPtr) {
				       *dict_scan_uintPtr = (unsigned int)(strtoul( yytext, NULL, 10 ));
				       *dict_scan_boolPtr = true;
				    }
				    else {
					 fprintf( stderr, "mplib error -- yylex() - Tried to read an unsigned int into"
						  " a NULL pointer.\n" );
					 return( ERROR_EVENT );
				    }
				    yy_pop_state();
				}

<SCAN_DOUBLE>[[:space:]]*[0-9\.eE\+-]+    {
					    if (dict_scan_doublePtr) {
					       *dict_scan_doublePtr = strtod( yytext, NULL );
					       *dict_scan_boolPtr = true;
					    }
					    else {
						 fprintf( stderr, "mplib error -- yylex() - Tried to read a double into"
							  " a NULL pointer.\n" );
						 return( ERROR_EVENT );
					    }
					    yy_pop_state();
					  }

<SCAN_STRING>[^\<\>]+ {
					    if (dict_scan_stringPtr) {
					       strcpy( dict_scan_stringPtr, yytext );
					       *dict_scan_boolPtr = true;
					    }
					    else {
						 fprintf( stderr, "mplib error -- yylex() - Tried to read a string into"
							  " a NULL pointer.\n" );
						 return( ERROR_EVENT );
					    }
					    yy_pop_state();
					  }


\<[[:space:]]*libVersion[[:space:]]*\>	{ /* <libVersion>: launch the Lib Version scanning */
					    BEGIN(SCAN_LIBVERSION);
					}

<SCAN_LIBVERSION>[[:space:]]*[a-zA-Z0-9\.\+-]+[[:space:]]*    { /* Copy the libVersion in scanInfo, then continue scanning. */
								strcpy( scanInfo->libVersion, yytext );
								BEGIN(INITIAL);
							      }

\<[[:space:]]*\/[[:space:]]*libVersion[[:space:]]*\>	{ /* </libVersion>: trash the ending
							     libVersion tag and continue scanning. */ ;
							}



\<[[:space:]]*block[[:space:]]*type[[:space:]]*=[[:space:]]*\"	{ /* <block type=": count the block
								     and scan the block type */
								  scanInfo->blockCount++;
								  yy_push_state(SCAN_BLOCKTYPE);
								}

<SCAN_BLOCKTYPE>[[:space:]]*[a-z]+[[:space:]]*  { /* Copy the block type in scanInfo, then continue scanning. */
						  strcpy( scanInfo->type, yytext );
						  yy_pop_state();
						}


\<[[:space:]]*par[[:space:]]*type[[:space:]]*=[[:space:]]*\" { /* <par type=" : launch the scanning of a local parameter. */
							       BEGIN( SCAN_PAR ); }

\<[[:space:]]*glob[[:space:]]*type[[:space:]]*=[[:space:]]*\" { /* <glob type=" : launch the scanning of a global parameter. */
								BEGIN( SCAN_GLOB ); }

<SCAN_PAR>windowLen { dict_scan_ulongPtr = &(scanInfo->windowLen);
		      dict_scan_boolPtr = &(scanInfo->windowLenIsSet);
		      yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>windowLen { dict_scan_ulongPtr = &(scanInfo->globWindowLen);
		       dict_scan_boolPtr = &(scanInfo->globWindowLenIsSet);
		       yy_push_state(SCAN_ULONG); }

<SCAN_PAR>windowShift { dict_scan_ulongPtr = &(scanInfo->windowShift);
			dict_scan_boolPtr = &(scanInfo->windowShiftIsSet);
			yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>windowShift { dict_scan_ulongPtr = &(scanInfo->globWindowShift);
			 dict_scan_boolPtr = &(scanInfo->globWindowShiftIsSet);
			 yy_push_state(SCAN_ULONG); }

<SCAN_PAR>windowRate { dict_scan_doublePtr = &(scanInfo->windowRate);
		       dict_scan_boolPtr = &(scanInfo->windowRateIsSet);
		       yy_push_state(SCAN_DOUBLE); }

<SCAN_GLOB>windowRate { dict_scan_doublePtr = &(scanInfo->globWindowRate);
			dict_scan_boolPtr = &(scanInfo->globWindowRateIsSet);
			yy_push_state(SCAN_DOUBLE); }

<SCAN_PAR>fftSize { dict_scan_ulongPtr = &(scanInfo->fftSize);
		    dict_scan_boolPtr = &(scanInfo->fftSizeIsSet);
		    yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>fftSize { dict_scan_ulongPtr = &(scanInfo->globFftSize);
		     dict_scan_boolPtr = &(scanInfo->globFftSizeIsSet);
		     yy_push_state(SCAN_ULONG); }

<SCAN_PAR>blockOffset { dict_scan_ulongPtr = &(scanInfo->blockOffset);
		       dict_scan_boolPtr = &(scanInfo->blockOffsetIsSet);
		       yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>blockOffset { dict_scan_ulongPtr = &(scanInfo->globBlockOffset);
			dict_scan_boolPtr = &(scanInfo->globBlockOffsetIsSet);
			yy_push_state(SCAN_ULONG); }

<SCAN_PAR>f0Min { dict_scan_doublePtr = &(scanInfo->f0Min);
		  dict_scan_boolPtr = &(scanInfo->f0MinIsSet);
		  yy_push_state(SCAN_DOUBLE); }

<SCAN_GLOB>f0Min { dict_scan_doublePtr = &(scanInfo->globF0Min);
		   dict_scan_boolPtr = &(scanInfo->globF0MinIsSet);
		   yy_push_state(SCAN_DOUBLE); }

<SCAN_PAR>f0Max { dict_scan_doublePtr = &(scanInfo->f0Max);
		  dict_scan_boolPtr = &(scanInfo->f0MaxIsSet);
		  yy_push_state(SCAN_DOUBLE); }

<SCAN_GLOB>f0Max { dict_scan_doublePtr = &(scanInfo->globF0Max);
		   dict_scan_boolPtr = &(scanInfo->globF0MaxIsSet);
		   yy_push_state(SCAN_DOUBLE); }

<SCAN_PAR>numPartials { dict_scan_uintPtr = &(scanInfo->numPartials);
			dict_scan_boolPtr = &(scanInfo->numPartialsIsSet);
			yy_push_state(SCAN_UINT); }

<SCAN_GLOB>numPartials { dict_scan_uintPtr = &(scanInfo->globNumPartials);
			 dict_scan_boolPtr = &(scanInfo->globNumPartialsIsSet);
			 yy_push_state(SCAN_UINT); }

<SCAN_PAR>tableFileName { dict_scan_stringPtr = scanInfo->tableFileName ;
			  dict_scan_boolPtr = &(scanInfo->tableFileNameIsSet);
			  yy_push_state(SCAN_STRING); }

<SCAN_GLOB>tableFileName { dict_scan_stringPtr = scanInfo->globTableFileName ;
			   dict_scan_boolPtr = &(scanInfo->globTableFileNameIsSet);
			   yy_push_state(SCAN_STRING); }

<SCAN_PAR>numFitPoints { dict_scan_uintPtr = &(scanInfo->numFitPoints);
			 dict_scan_boolPtr = &(scanInfo->numFitPointsIsSet);
			 yy_push_state(SCAN_UINT); }

<SCAN_GLOB>numFitPoints { dict_scan_uintPtr = &(scanInfo->globNumFitPoints);
			  dict_scan_boolPtr = &(scanInfo->globNumFitPointsIsSet);
			  yy_push_state(SCAN_UINT); }

<SCAN_PAR>numIter { dict_scan_uintPtr = &(scanInfo->numIter);
		    dict_scan_boolPtr = &(scanInfo->numIterIsSet);
		    yy_push_state(SCAN_UINT); }

<SCAN_GLOB>numIter { dict_scan_uintPtr = &(scanInfo->globNumIter);
		     dict_scan_boolPtr = &(scanInfo->globNumIterIsSet);
		     yy_push_state(SCAN_UINT); }

<*>\"[[:space:]]*\>  /* Ignore the tag endings after scanning any attribute
			(e.g., after SCAN_BLOCKTYPE, SCAN_PAR etc.). */ ;

<SCAN_GLOB,SCAN_PAR>\<[[:space:]]*\/[[:space:]]*((glob)|(par))[[:space:]]*\> { /* </par>: When exiting a parameter, reset
						       the output value pointers and continue scanning. */
						       dict_scan_ulongPtr = NULL;
						       dict_scan_uintPtr = NULL;
						       dict_scan_doublePtr = NULL;
						       dict_scan_boolPtr = NULL;
						       dict_scan_stringPtr = NULL;
						       BEGIN(INITIAL);
						     }


\<[[:space:]]*window[[:space:]]* { /* <window: launch the scanning of a window. */
				   dict_scan_ucharPtr = &(scanInfo->windowType);
				   dict_scan_boolPtr2 = &(scanInfo->windowTypeIsSet);
				   dict_scan_doublePtr = &(scanInfo->windowOption);
				   dict_scan_boolPtr = &(scanInfo->windowOptionIsSet);
				   BEGIN( SCAN_WINDOW ); }

\<[[:space:]]*glob[[:space:]]*window[[:space:]]* { /* <glob window: launch the scanning of a glob window. */
						      dict_scan_ucharPtr = &(scanInfo->globWindowType);
						      dict_scan_boolPtr2 = &(scanInfo->globWindowTypeIsSet);
						      dict_scan_doublePtr = &(scanInfo->globWindowOption);
						      dict_scan_boolPtr = &(scanInfo->globWindowOptionIsSet);
						      BEGIN( SCAN_WINDOW ); }

<SCAN_WINDOW>[[:space:]]*type[[:space:]]*=[[:space:]]*\" { /* type=" : launch the scanning of the type. */
							   yy_push_state( SCAN_WINDOWTYPE ); }

<SCAN_WINDOW>[[:space:]]*opt[[:space:]]*=[[:space:]]*\" { /* opt=" : launch the scanning of the type. */
							  yy_push_state( SCAN_DOUBLE ); }

<SCAN_WINDOWTYPE>[[:space:]]*[a-z]+    { *dict_scan_ucharPtr = window_type( yytext ); dict_scan_ucharPtr = NULL;
					 *dict_scan_boolPtr2 = true;                  dict_scan_boolPtr2 = NULL;
					 yy_pop_state(); }

<SCAN_WINDOW>\"[[:space:]]*  { /* Skip the isolated attribute endings. */ ; }

<SCAN_WINDOW>\"[[:space:]]*\>\<[[:space:]]*\/[[:space:]]*window[[:space:]]*\>  { /* Skip the tag ending
										 and return to the INITIAL
										 scanning state */
										 BEGIN(INITIAL); }


\<[[:space:]]*\/[[:space:]]*block[[:space:]]*\>    { /* </block>: Return after the closing block tag. */
						     return( COMPLETED_BLOCK ); }



\<[[:space:]]*dict[[:space:]]*\>	/* <dict>: ignore the tag. */ ;

\<[[:space:]]*\/[[:space:]]*dict[[:space:]]*\>   { /* </dict>: Return after the closing dict tag. */
						   return( DICT_CLOSE ); }


<<EOF>>  { /* Inform the outside world that we reached the end of the file. */
	   return( REACHED_END_OF_FILE );
	 }

%%


int dict_scanner( FILE *fid, MP_Scan_Info_c *scanInfo ) {

    yyin = fid;
    yyout = stderr;

    return( yylex( scanInfo ) );
}

