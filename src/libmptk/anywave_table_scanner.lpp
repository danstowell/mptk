%{

/******************************************************************************/
/*                                                                            */
/*                        anywave_table_scanner.lpp                           */
/*                                                                            */
/*                        Matching Pursuit Library                            */
/*                                                                            */
/* Rémi Gribonval                                                             */
/* Sacha Krstulovic                                                           */
/* Sylvain Lesage                                             Mon Nov 21 2005 */
/* -------------------------------------------------------------------------- */
/*                                                                            */
/*  Copyright (C) 2005 IRISA                                                  */
/*                                                                            */
/*  This program is free software; you can redistribute it and/or             */
/*  modify it under the terms of the GNU General Public License               */
/*  as published by the Free Software Foundation; either version 2            */
/*  of the License, or (at your option) any later version.                    */
/*                                                                            */
/*  This program is distributed in the hope that it will be useful,           */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/*  GNU General Public License for more details.                              */
/*                                                                            */
/*  You should have received a copy of the GNU General Public License         */
/*  along with this program; if not, write to the Free Software               */
/*  Foundation, Inc., 59 Temple Place - Suite 330,                            */
/*  Boston, MA  02111-1307, USA.                                              */
/*                                                                            */
/******************************************************************************/
/*
 * SVN log:
 *
 * $Author: sacha $
 * $Date$
 * $Revision$
 *
 */

/* The anywave_table_scanner.cpp source is automatically generated from
   the anywave_table_scanner.l template, using the FLEX lexical scanner generator.
   Any manual change will be lost at the next build. Changes should be introduced
   in the anywave_table_scanner.l file. See "man flex" for more info. */

#include "mptk.h"
#include "mp_system.h"

#include <dsp_windows.h>

/* Redefine yylex to take a MP_Anywave_Table_Scan_Info_c* as input */
#define YY_DECL unsigned short int yylex_anywave_table( MP_Anywave_Table_Scan_Info_c *scanInfo )

/* A few global variables */
unsigned long int *anywave_table_scan_ulongPtr = NULL;
unsigned short int *anywave_table_scan_ushortPtr = NULL;
char* anywave_table_scan_stringPtr = NULL;
bool *anywave_table_scan_boolPtr = NULL;

%}

%option noyywrap
%option stack
%option prefix="anywave_table_scan_" outfile="lex.yy.c"

%x SCAN_ULONG
%x SCAN_USHORT
%x SCAN_STRING

%s SCAN_LIBVERSION
%s SCAN_PAR
%s SCAN_GLOB

%%

[[:space:]]+	/* Trash the isolated series of blank spaces */ ;

\<\?xml.*\?\>	/* Ignore the XML declaration line */ ;

\<!--(.|\n)*--\>	/* Trash any XML style comments */ ;

#.*$		/* Trash any shell-style comments */ ;



<SCAN_ULONG>[[:space:]]*-?[[:space:]]*[0-9]*[[:alpha:]\.\+-]+.*/\<    {
					fprintf( stderr, "mplib error -- yylex() - [%s] is a wrong string"
						  " to describe an unsigned long int value. Please check the syntax"
						  " of your table and use only the digits from 0 to 9.\n",
						  yytext );
					return( ANYWAVE_TABLE_ERROR_EVENT );
				}

<SCAN_ULONG>[[:space:]]*-?[[:space:]]*[0-9]+    {
				    if (anywave_table_scan_ulongPtr) {
				       *anywave_table_scan_ulongPtr = strtoul( yytext, NULL, 10 );
				       *anywave_table_scan_boolPtr = true;
				    }
				    else {
					 fprintf( stderr, "mplib error -- yylex() - Tried to read an unsigned long int into"
						  " a NULL pointer.\n" );
					 return( ANYWAVE_TABLE_ERROR_EVENT );
				    }
				    yy_pop_state();
				}

<SCAN_USHORT>[[:space:]]*-?[[:space:]]*[0-9]*[[:alpha:]\.\+-]+.*/\<    {
					fprintf( stderr, "mplib error -- yylex() - [%s] is a wrong string"
						  " to describe a unsigned short int value. Please check the syntax"
						  " of your table and use only the digits from 0 to 9.\n",
						  yytext );
					return( ANYWAVE_TABLE_ERROR_EVENT );
				}

<SCAN_USHORT>[[:space:]]*-?[[:space:]]*[0-9]+    {
				    if (anywave_table_scan_ushortPtr) {
				       *anywave_table_scan_ushortPtr = strtoul( yytext, NULL, 10 );
				       *anywave_table_scan_boolPtr = true;
				    }
				    else {
					 fprintf( stderr, "mplib error -- yylex() - Tried to read an unsigned short int into"
						  " a NULL pointer.\n" );
					 return( ANYWAVE_TABLE_ERROR_EVENT );
				    }
				    yy_pop_state();
				}

<SCAN_STRING>[^\<\>]+  {
					    if (anywave_table_scan_stringPtr) {
					       strcpy( anywave_table_scan_stringPtr, yytext );
					       *anywave_table_scan_boolPtr = true;
					    }
					    else {
						 fprintf( stderr, "mplib error -- yylex() - Tried to read a string into"
							  " a NULL pointer.\n" );
						 return( ANYWAVE_TABLE_ERROR_EVENT );
					    }
					    yy_pop_state();
					  }


\<[[:space:]]*libVersion[[:space:]]*\>	{ /* <libVersion>: launch the Lib Version scanning */
					    BEGIN(SCAN_LIBVERSION);
					}

<SCAN_LIBVERSION>[[:space:]]*[a-zA-Z0-9\.\+-]+[[:space:]]*    { /* Copy the libVersion in scanInfo, then continue scanning. */
								strcpy( scanInfo->libVersion, yytext );
								BEGIN(INITIAL);
							      }

\<[[:space:]]*\/[[:space:]]*libVersion[[:space:]]*\>	{ /* </libVersion>: trash the ending
							     libVersion tag and continue scanning. */ ;
							}


\<[[:space:]]*table[[:space:]]*\"	{ /* <table": opens the table */
					  yy_pop_state();
					}


\<[[:space:]]*par[[:space:]]*type[[:space:]]*=[[:space:]]*\" { /* <par type=" : launch the scanning of a local parameter. */
							       BEGIN( SCAN_PAR ); }

\<[[:space:]]*glob[[:space:]]*type[[:space:]]*=[[:space:]]*\" { /* <glob type=" : launch the scanning of a global parameter. */
								BEGIN( SCAN_GLOB ); }

<SCAN_PAR>filterLen { anywave_table_scan_ulongPtr = &(scanInfo->filterLen);
		      anywave_table_scan_boolPtr = &(scanInfo->filterLenIsSet);
		      yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>filterLen { anywave_table_scan_ulongPtr = &(scanInfo->globFilterLen);
		       anywave_table_scan_boolPtr = &(scanInfo->globFilterLenIsSet);
		       yy_push_state(SCAN_ULONG); }

<SCAN_PAR>numFilters { anywave_table_scan_ulongPtr = &(scanInfo->numFilters);
		       anywave_table_scan_boolPtr = &(scanInfo->numFiltersIsSet);
		       yy_push_state(SCAN_ULONG); }

<SCAN_GLOB>numFilters { anywave_table_scan_ulongPtr = &(scanInfo->globNumFilters);
	 	        anywave_table_scan_boolPtr = &(scanInfo->globNumFiltersIsSet);
		        yy_push_state(SCAN_ULONG); }

<SCAN_PAR>numChans { anywave_table_scan_ushortPtr = &(scanInfo->numChans);
		     anywave_table_scan_boolPtr = &(scanInfo->numChansIsSet);
		     yy_push_state(SCAN_USHORT); }

<SCAN_GLOB>numChans { anywave_table_scan_ushortPtr = &(scanInfo->globNumChans);
	 	      anywave_table_scan_boolPtr = &(scanInfo->globNumChansIsSet);
		      yy_push_state(SCAN_USHORT); }

<SCAN_PAR>data { anywave_table_scan_stringPtr = scanInfo->dataFileName;
   		 anywave_table_scan_boolPtr = &(scanInfo->dataFileNameIsSet);
		 yy_push_state(SCAN_STRING); }

<SCAN_GLOB>data { anywave_table_scan_stringPtr = scanInfo->globDataFileName;
   		  anywave_table_scan_boolPtr = &(scanInfo->globDataFileNameIsSet);
		  yy_push_state(SCAN_STRING); }


<*>\"[[:space:]]*\>  /* Ignore the tag endings after scanning any attribute
			(e.g., after SCAN_PAR etc.). */ ;

<SCAN_GLOB,SCAN_PAR>\<[[:space:]]*\/[[:space:]]*((glob)|(par))[[:space:]]*\> { /* </par>: When exiting a parameter, reset
						       the output value pointers and continue scanning. */
						       anywave_table_scan_ulongPtr = NULL;
						       anywave_table_scan_ushortPtr = NULL;	
						       anywave_table_scan_boolPtr = NULL;
						       anywave_table_scan_stringPtr = NULL;
						       BEGIN(INITIAL);
						     }

\<[[:space:]]*table[[:space:]]*\>	/* <table>: ignore the tag. */ ;

\<[[:space:]]*\/[[:space:]]*table[[:space:]]*\>   { /* </table>: Return after the closing table tag. */
						   return( ANYWAVE_TABLE_CLOSE ); }


<<EOF>>  { /* Inform the outside world that we reached the end of the file. */
	   return( ANYWAVE_TABLE_REACHED_END_OF_FILE );
	 }

%%


unsigned short int anywave_table_scanner( FILE *fid, MP_Anywave_Table_Scan_Info_c *scanInfo ) {

    yyin = fid;
    yyout = stderr;

    return( yylex_anywave_table( scanInfo ) );
}

